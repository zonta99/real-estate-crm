# CLAUDE.md - AI Assistant Guide

> **Last Updated**: 2025-11-20 | **Version**: 1.1
> Real Estate CRM backend (Spring Boot 3.2.5 + Java 21)

## Project Overview

**Tech Stack**: Spring Boot 3.2.5, Java 21, Spring Security (JWT), MapStruct, H2/PostgreSQL, SpringDoc OpenAPI

**Core Features**: User management (ADMIN/BROKER/AGENT/ASSISTANT roles), Property CRUD with dynamic attributes, Customer CRM, Saved searches

## Architecture

**Layered N-Tier**: Controller (REST + Auth) → Service (@Transactional) → Repository (JPA) → Entity

**Critical Flow**: JWT Filter → Controller (@Valid, @PreAuthorize) → Service (business logic) → Repository (@EntityGraph) → **Convert to DTO within transaction** → Response

**Patterns**: Repository, Service Layer, DTO, MapStruct Mapper, Factory (AttributeValue), Strategy (SecurityConfig)

## Structure

```
src/main/java/com/realestatecrm/
├── controller/     # 6 REST APIs: Auth, Property, Customer, User, PropertyAttribute, SavedSearch
├── service/        # 8 services with @Transactional
├── repository/     # 13 JPA repositories
├── entity/         # 13 JPA entities
├── dto/            # Request/Response DTOs (property/, customer/, user/, auth/, common/)
├── mapper/         # 6 MapStruct mappers
├── security/       # JwtUtils, AuthTokenFilter
├── enums/          # Role, PropertyStatus, CustomerStatus, PropertyDataType, etc.
├── exception/      # GlobalExceptionHandler
└── config/         # SecurityConfig, DatabaseConfig, DataLoader

docs/  # Frontend-Integration-Guide.md, Lazy-Initialization-Prevention.md (CRITICAL!)
```

## Domain Model

**Entities**: User (1:N Properties, Customers) → Property (1:N AttributeValues) → PropertyAttribute (1:N Options) | Customer (1:N SavedSearch, Interactions, Notes)

**Enums**: Role (ADMIN/BROKER/AGENT/ASSISTANT), PropertyStatus (ACTIVE/INACTIVE/SOLD), CustomerStatus (LEAD/QUALIFIED/NEGOTIATING/SOLD/LOST), PropertyDataType (TEXT/NUMBER/BOOLEAN/DATE/SINGLE_SELECT/MULTI_SELECT)

## Quick Commands

```bash
# Setup (requires: Java 21, Maven 3.6+)
export JWT_SECRET=$(openssl rand -base64 64) ADMIN_PASSWORD="Secure123!" CORS_ALLOWED_ORIGINS="http://localhost:3000"
./mvnw spring-boot:run  # Dev mode (H2) → http://localhost:8080/swagger-ui

# Testing & Build
./mvnw test  # Run all tests
./mvnw clean package -DskipTests  # Build JAR
```

## Conventions

**Naming**: `[Entity]Controller/Service/Repository/Mapper`, `[Action][Entity]Request`, `[Entity]Response`
**Endpoints**: `/api/{auth|properties|customers|users|property-attributes|saved-searches}/*`
**Methods**: GET (retrieve), POST (create), PUT (update), DELETE (delete)

## Critical Patterns

### New Feature Workflow
1. Entity (JPA annotations) → 2. Repository (extends JpaRepository) → 3. Service (@Transactional) → 4. DTOs (request/response records) → 5. Mapper (MapStruct) → 6. Controller (@PreAuthorize, @Valid) → 7. Tests

### MapStruct (ALWAYS use for DTO conversion)

```java
@Mapper(componentModel = "spring")
public interface PropertyMapper {

    // Entity → Response (for GET requests)
    default PropertyResponse toResponse(Property property) {
        if (property == null) return null;
        return new PropertyResponse(
            property.getId(),
            property.getTitle(),
            property.getAgent().getFullName()  // Access within transaction!
        );
    }

    // Request → Entity (for POST/PUT requests)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "agent", ignore = true)  // Set manually in controller
    @Mapping(target = "createdDate", ignore = true)  // Managed by JPA
    @Mapping(target = "updatedDate", ignore = true)
    Property toEntity(CreatePropertyRequest request);

    // List mapping (auto-generated by MapStruct)
    List<PropertyResponse> toResponseList(List<Property> properties);
}
```

**Rules**: `componentModel = "spring"`, `@Mapping(target, ignore = true)` for JPA-managed fields, `default` methods for records/complex logic

### Service (CRITICAL: Convert to DTO within @Transactional!)

```java
@Service
@Transactional  // Class-level default
public class PropertyService {
    @Transactional(readOnly = true)  // Read optimization
    public PropertyResponse getById(Long id) {
        Property p = repository.findByIdWithAgent(id).orElseThrow(...);
        return mapper.toResponse(p);  // MUST convert within transaction!
    }
    public PropertyResponse create(CreatePropertyRequest req, User user) {
        Property p = mapper.toEntity(req);
        p.setAgent(user);  // Set @Mapping-ignored fields manually
        return mapper.toResponse(repository.save(p));
    }
}
```

### Controller

```java
@RestController @RequestMapping("/api/properties")
public class PropertyController {
    @GetMapping("/{id}") @PreAuthorize("hasAnyRole('AGENT', 'BROKER', 'ADMIN')")
    public ResponseEntity<PropertyResponse> getById(@PathVariable Long id) {
        return ResponseEntity.ok(propertyService.getById(id));
    }

    @PostMapping @PreAuthorize("hasRole('AGENT') or hasRole('BROKER')")
    public ResponseEntity<PropertyResponse> create(
            @Valid @RequestBody CreatePropertyRequest req,
            @AuthenticationPrincipal UserDetails userDetails) {
        User user = userService.findByUsername(userDetails.getUsername());
        return ResponseEntity.status(CREATED).body(propertyService.create(req, user));
    }
}
```

**Rules**: `@Valid` for validation, `@AuthenticationPrincipal` for current user, `@PreAuthorize` for security, return `ResponseEntity<DTO>` (NEVER entities)

### Repository (@EntityGraph prevents LazyInitializationException)

```java
@Repository
public interface PropertyRepository extends JpaRepository<Property, Long> {
    @EntityGraph(attributePaths = {"agent"})  // Eagerly fetch agent
    Optional<Property> findByIdWithAgent(Long id);

    @EntityGraph(attributePaths = {"agent", "attributeValues", "attributeValues.attribute"})
    Optional<Property> findByIdWithDetails(Long id);
}
```

**Use @EntityGraph** when accessing lazy relationships or serializing to JSON

### DTOs (Use Java Records)

```java
public record PropertyResponse(Long id, String title, BigDecimal price, String agentName) {}

public record CreatePropertyRequest(
    @NotBlank @Size(min=3, max=255) String title,
    @NotNull @DecimalMin("0.01") BigDecimal price
) {}
```

**Validation**: @NotNull, @NotBlank, @Size, @Email, @DecimalMin/Max, @Pattern, @Valid (nested)

### Exceptions (GlobalExceptionHandler)
- EntityNotFoundException → 404
- IllegalArgumentException → 400
- AccessDeniedException → 403
- DataIntegrityViolationException → 409

---

## Security

**Auth Flow**: POST /api/auth/login → {token, refreshToken} → Client sends `Authorization: Bearer <token>` → Token expires 24h → POST /api/auth/refresh

**Authorization**: `@PreAuthorize("hasRole('ADMIN')")` | `@PreAuthorize("hasAnyRole('AGENT', 'BROKER')")` | `@PreAuthorize("@permissionService.canAccessProperty(#id, principal)")`

**Roles**: ADMIN (all) > BROKER (manage agents, view all) > AGENT (manage properties/customers) > ASSISTANT (read-only)

**Checklist**: Use @PreAuthorize, @Valid, @AuthenticationPrincipal | Check ownership (prevent IDOR) | Never log secrets | Parameterized queries

**Env Vars (Required)**: `JWT_SECRET` (openssl rand -base64 64), `ADMIN_PASSWORD` (min 12 chars), `CORS_ALLOWED_ORIGINS`

## Testing

```java
@SpringBootTest @AutoConfigureMockMvc @ActiveProfiles("dev")
class PropertyControllerTests {
    @Test @WithMockUser(username="agent", roles={"AGENT"})
    void shouldCreateProperty() throws Exception {
        mockMvc.perform(post("/api/properties").contentType(JSON).content(...))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.title").value("Test"));
    }
}
```

**Utilities**: @SpringBootTest, @AutoConfigureMockMvc, @WithMockUser, @Transactional (rollback)

---

## ⚠️ CRITICAL PITFALLS

### 1. LazyInitializationException (MOST COMMON BUG!)
**Problem**: Accessing lazy relationships outside @Transactional → exception
**Fix**: Use @EntityGraph OR convert to DTO within transaction
```java
// ✅ GOOD: @EntityGraph
@EntityGraph(attributePaths = {"agent"})
Optional<Property> findByIdWithAgent(Long id);

// ✅ GOOD: Convert within transaction
@Transactional(readOnly = true)
public PropertyResponse get(Long id) {
    return mapper.toResponse(repository.findById(id).get());  // Convert before return!
}
```
**See**: `/docs/Lazy-Initialization-Prevention.md`

### 2. Returning Entities from Controllers
❌ **NEVER** return entities → use DTOs (prevents LazyInitializationException, security leaks, API coupling)

### 3. Missing @Transactional
❌ Service without `@Service @Transactional` → may not commit
✅ Use class-level `@Transactional`, method-level `@Transactional(readOnly = true)` for reads

### 4. Missing @Valid
❌ `@RequestBody` without `@Valid` → no validation
✅ Always use `@Valid @RequestBody`

### 5. Hardcoded Secrets
❌ `String jwtSecret = "key"` → security risk
✅ `@Value("${jwt.secret}")` + env vars

### 6. Manual DTO Mapping
❌ Manual setters → error-prone
✅ Always use MapStruct

### 7. Forgetting to Set @Mapping-Ignored Fields
When using `@Mapping(target = "agent", ignore = true)`, MUST set manually in controller: `property.setAgent(currentUser)`

---

## Quick Reference

**Locations**: controller/ (REST), service/ (business logic), repository/ (queries), entity/, dto/, mapper/, config/SecurityConfig, exception/GlobalExceptionHandler, enums/, security/JwtUtils

**URLs**: Swagger UI (http://localhost:8080/swagger-ui), Health (/actuator/health), H2 Console (/h2-console)

**Key Endpoints**: POST /api/auth/login|refresh|logout, GET|POST|PUT|DELETE /api/{properties|customers|users}/{id}, POST /api/property-attributes (admin)

**Read First**: docs/Lazy-Initialization-Prevention.md (CRITICAL!), SECURITY.md, README.md

## AI Assistant Guidelines

**When Coding**:
1. Read similar code first → Follow established patterns
2. Use MapStruct (never manual mapping), Java records (DTOs), @EntityGraph (lazy relationships)
3. Add @Valid, @PreAuthorize, @Transactional
4. Write tests (happy path + errors)
5. Check security (no secrets, validate ownership)

**New Entity Flow**: Entity → Repository → Service (@Transactional) → DTOs (records) → Mapper → Controller (@PreAuthorize) → Tests

**Fix LazyInitializationException**: Add @EntityGraph to repository OR convert to DTO within @Transactional

---

**Key Takeaways**: Layered architecture | MapStruct mandatory | @EntityGraph prevents lazy loading errors | DTOs everywhere | Convert within transactions | Security first (validate, authorize, sanitize)

**Docs**: CLAUDE.md (this), SECURITY.md, docs/Lazy-Initialization-Prevention.md, docs/Frontend-Integration-Guide.md

---

*Last Updated: 2025-11-20 | v1.1*
